---
title: "AFM_dash4"
author: "Mazama Science"
date: "3/17/2021"
output: html_document
runtime: shiny
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(AirFireModeling)
library(shiny)
library(crosstalk)
library(lubridate)
library(leaflet)
library(gt)
library(MazamaSpatialUtils)


library(MazamaSpatialUtils)
library(AirFireModeling)
library(AirFireWRF)
library(AirFirePlots)

PWFSLSmoke::initializeMazamaSpatialUtils()
MazamaSpatialUtils::setSpatialDataDir("~/Data/Spatial")
setModelDataDir('~/Data/BlueSky')
setWRFDataDir('~/Data/WRF')
```

```{css, echo = FALSE}

.btn {
  margin-left: 80%;
  background-color: whitesmoke;
}

```


```{r model_date_panel}

inputPanel(
    selectizeInput(
      "model", 
      label = "Model Name",
      choices = c(
      "PNW-1.33km",
      "PNW-4km",
      "CANSAC-1.33km",
      "CANSAC-4km"
    ),
      width = "100%"
    ), 
    dateInput(
      "date", 
      label = "Model Run Date", 
      max = today(), 
      width = "100%"
    ), 
    
    actionButton(
      "opts", 
      "", 
      icon = icon("cog")
    )

  )
    uiOutput(
      "loadLink"
    )  
```

```{r main_panel, message=FALSE}

plotOutput("plot")

gt_output("table")
```

```{r backend}



meta <- eventReactive({ input$load }, {
  bluesky_modelInfo  %>% 
    dplyr::filter(.data$modelName == input$model)
})

bs <- eventReactive({ input$load }, {
  
  raster <- tryCatch(raster_load(
    modelName = input$model, 
    modelRun = strftime(input$date, "%Y%m%d00")
  ), error = function(err) { NULL })


  
  return(raster)
  
})

wrf <- eventReactive({ input$load }, {
  
  # WRF-only parameters
  modelRunHour <- 24
  varNames <- c("U10", "V10")   #  Wind vector components
  res <- 0.1                    # Use res = 0.1 for state-sized regions
  
  xlim <- c(meta()[['MIN_LONGITUDE']], meta()[['MAX_LONGITUDE']])
  ylim <- c(meta()[['MIN_LATITUDE']], meta()[['MAX_LATITUDE']])
  
  wrf <- wrf_load(
    modelName = input$model,
    modelRun = strftime(input$date, "%Y%m%d00"),
    modelRunHour = modelRunHour,
    varNames = varNames,
    res = res, 
    xlim = xlim, 
    ylim = ylim
  )
  
})

```


```{r outputs}

output$loadLink <- renderUI({
  
  req(input$model)
  actionButton(
    inputId = "load",
    label = tags$h4(paste("Load", input$model))
  ) 
  
})

# output$map <- renderLeaflet({
#   
#  leaflet() %>%
#   addTiles() 
#   
# })

output$plot <- renderPlot({
  
  req(meta(), bs(), wrf())
  
  p <- Progress$new()
  
  p$set(message = "Loading Model Info...", value = 0)
  meta <- meta()
  
  p$set(message = "Loading Bluesky Model...", value = 33)
  bs_raster <- bs()[[1]]
  
  p$set(message = "Loading WRF Model...", value = 66)
  wrf_raster <- wrf()
  
  
  xlim <- c(meta[['MIN_LONGITUDE']], meta[['MAX_LONGITUDE']])
  ylim <- c(meta[['MIN_LATITUDE']], meta[['MAX_LATITUDE']])
  
  states <- MazamaSpatialUtils::getState(xlim[1], ylim[1])
  
  g <- plot_base(
    xlim = xlim, 
    ylim = ylim, 
    ratio = 1.4
    
  ) + 
    layer_raster(
      raster = bs_raster[[1]], 
      breaks = c(0, 1, 2, 5, 10, 25, 50, 100, Inf)
    ) + 
    layer_counties(
      fill = "transparent", 
      xlim = xlim,
      ylim = ylim
    ) + 
    layer_states(
      xlim = xlim, 
      ylim = ylim
    ) + 
    layer_vectorField(
      raster = wrf_raster, 
      uName = "U10", 
      vName = "V10"
    ) + 
    ggplot2::scale_fill_brewer(
    palette = "Greys",
    na.value = "transparent"
  )
  
  p$close()
  
  return(g)
  
  # req(bs(), coords())
  # raster_spaghettiPlot(bs(), coords()$lng , coords()$lat)
  
#   gg <- plot_base(
#   title = sprintf("Bluesky Forecast for hour %d", 24),
#   xlab = "Longitude",
#   ylab = "Latitude",
#   clab = NULL,
#   flab = "PM2.5",
#   # xlim = xlim,
#   # ylim = ylim,
#   ratio = 1.4,                # Appropriate for Washington
#   expand = FALSE
# ) +
#   layer_raster(
#     raster = bs()[[modelRunHour]],
#     varName = NULL,
#     naRemove = FALSE,
#     breaks = c(0, 1, 2, 5, 10, 25, 50, 100, Inf),
#     alpha = 1
#   ) +
#   layer_counties(
#     lineWidth = 0.3,
#     color = "gray80",
#     fill = "transparent",
#     xlim = xlim,
#     ylim = ylim
#   ) +
#   layer_states(
#     stateCodes = c(stateCode),
#     xlim = xlim,
#     ylim = ylim,
#     lineWidth = 0.5,
#     color = "firebrick",
#     fill = "transparent",
#   ) +
#   layer_vectorField(
#     raster = wrf,
#     uName = "U10",
#     vName = "V10",
#     #arrowCount = 1000,
#     #arrowScale = 0.05,
#     #headLength = ggplot2::unit(0.05, "inches"),
#     #headAngle = 60,
#     #lineWidth = 0.3,
#     alpha = 0.6,
#     xlim = xlim,
#     ylim = ylim
#   ) +
#   ggplot2::scale_fill_brewer(
#     palette = "Greys",
#     na.value = "transparent"
#   )

})

# output$table <- render_gt({
#   req(bs(), coords())
#   df <- raster_toMonitor(bs()[[1]][[input$index]], coords()$lng, coords()$lat)
#   gt(df$data)
# })
```
