---
title: "AFM_dash4"
author: "Mazama Science"
date: "3/17/2021"
output: html_document
runtime: shiny
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(AirFireModeling)
library(shiny)
library(crosstalk)
library(lubridate)
library(leaflet)
library(gt)
library(MazamaSpatialUtils)


library(MazamaSpatialUtils)
library(AirFireModeling)
library(AirFireWRF)
library(AirFirePlots)



PWFSLSmoke::initializeMazamaSpatialUtils()
MazamaSpatialUtils::setSpatialDataDir("~/Data/Spatial")
setModelDataDir('~/Data/BlueSky')
setWRFDataDir('~/Data/WRF')
```

```{css, echo = FALSE}

.btn {
  margin-left: 80%;
  background-color: whitesmoke;
}

.btn#opts_bt {
  margin-top: 12%
}

```

```{js, echo = FALSE}

// Hide options by default
$('#opts_menu').parent().hide()

// Options toggle
$('#opts_bt').on('click', () => {
  $('#opts_menu').parent().toggle()
})

```


```{r model_date_panel}

# Begin UI def
inputPanel(
    selectizeInput(
      "model", 
      label = "Model Name",
      choices = c(
      "PNW-1.33km",
      "PNW-4km",
      "CANSAC-1.33km",
      "CANSAC-4km"
    ),
      width = "100%"
    ), 
    dateInput(
      "date", 
      label = "Model Run Date", 
      max = today(), 
      width = "100%"
    ), 
      selectizeInput(
    "index", 
    "4) Forecast Slice", 
    choices = "", 
    width = "80%"
    ),
    actionButton(
      "opts_bt", 
      "", 
      icon = icon("cog")
    ), 
    id = "main"
  )

inputPanel(
  checkboxGroupInput(
    "options", 
    "Plot Options",
    choices = c(
      "State Boundaries", 
      "County Boundaries",
      "Scalar Field", 
      "Vector Field"
    ), 
  ), 
  id = "opts_menu"
)

uiOutput("loadLink")  
    
plotOutput("plot")

gt_output("table")

# # # End UI def
# # # Begin Logic

meta <- eventReactive({ input$load }, {
  bluesky_modelInfo  %>% 
    dplyr::filter(.data$modelName == input$model)
})

bs <- eventReactive({ input$load }, {
  
  raster <- tryCatch(raster_load(
    modelName = input$model, 
    modelRun = strftime(input$date, "%Y%m%d00")
  ), error = function(err) { NULL })


  
  return(raster)
  
})

wrf <- eventReactive({ input$load }, {
  
  # WRF-only parameters
  modelRunHour <- 24
  varNames <- c("U10", "V10")   #  Wind vector components
  res <- 0.1                    # Use res = 0.1 for state-sized regions
  
  xlim <- c(meta()[['MIN_LONGITUDE']], meta()[['MAX_LONGITUDE']])
  ylim <- c(meta()[['MIN_LATITUDE']], meta()[['MAX_LATITUDE']])
  
  wrf <- wrf_load(
    modelName = input$model,
    modelRun = strftime(input$date, "%Y%m%d00"),
    modelRunHour = modelRunHour,
    varNames = varNames,
    res = res, 
    xlim = xlim, 
    ylim = ylim
  )
  
  return(wrf)
  
})

index <- eventReactive({ input$index }, {
  return(as.numeric(input$index))
})

observeEvent({ input$load }, {
  
    updateSelectizeInput(
    session,
    "index",
    choices = tryCatch(
      expr = 1:dim(bs()[[1]])[3], 
      error = function(err) { "Error." }
    )
  )
  
})

options <- eventReactive({ input$options }, {
  return(input$options)
})

output$loadLink <- renderUI({
  
  req(input$model)
  actionButton(
    inputId = "load",
    label = tags$h4(paste("Load", input$model))
  ) 
  
})

output$plot <- renderPlot({
  
  req(meta(), bs(), wrf(), index())
  
  meta <- meta()
  
  bs_raster <- bs()[[1]]
  
  wrf_raster <- wrf()
  
  
  xlim <- c(meta[['MIN_LONGITUDE']], meta[['MAX_LONGITUDE']])
  ylim <- c(meta[['MIN_LATITUDE']], meta[['MAX_LATITUDE']])
  
  states <- MazamaSpatialUtils::getState(xlim[1], ylim[1])
  
  g <- plot_base(
    xlim = xlim, 
    ylim = ylim, 
    ratio = 1.4
  ) + 
    (if ( "Scalar Field" %in% options() ) {
      layer_raster(
        raster = bs_raster[[index()]], 
        breaks = c(0, 1, 2, 5, 10, 25, 50, 100, Inf)
      ) 
    })+ 
    (if ( "County Boundaries" %in% options() ) {
      layer_counties(
        fill = "transparent", 
        xlim = xlim,
        ylim = ylim
      )
    }) + 
    (if ( "State Boundaries" %in% options() ) { 
      layer_states(
        xlim = xlim, 
        ylim = ylim
      )
    }) + 
    (if ( "Vector Field" %in% options() ) { 
      layer_vectorField(
        raster = wrf_raster, 
        uName = "U10", 
        vName = "V10"
      )
    }) + 
    ggplot2::scale_fill_brewer(
    palette = "Greys",
    na.value = "transparent"
  )
  
  return(g)

})

# output$table <- render_gt({
#   req(bs(), coords())
#   df <- raster_toMonitor(bs()[[1]][[input$index]], coords()$lng, coords()$lat)
#   gt(df$data)
# })
```
